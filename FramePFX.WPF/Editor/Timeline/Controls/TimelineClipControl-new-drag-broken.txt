using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Controls.Primitives;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Threading;
using FramePFX.Editor;
using FramePFX.Editor.ResourceManaging.ViewModels;
using FramePFX.Editor.ViewModels.Timelines;
using FramePFX.Utils;
using FramePFX.WPF.Editor.Timeline.Utils;
using OpenTK.Graphics.ES30;

namespace FramePFX.WPF.Editor.Timeline.Controls {
    public sealed class TimelineClipControl : Control {
        private static readonly object LongZeroObject = 0L;

        public static readonly DependencyProperty IsSelectedProperty =
            Selector.IsSelectedProperty.AddOwner(
                typeof(TimelineClipControl),
                new FrameworkPropertyMetadata(
                    BoolBox.False,
                    FrameworkPropertyMetadataOptions.BindsTwoWayByDefault | FrameworkPropertyMetadataOptions.Journal,
                    (d, e) => ((TimelineClipControl) d).OnSelectionChanged((bool)e.NewValue)));

        public static readonly DependencyProperty FrameBeginProperty =
            DependencyProperty.Register(
                "FrameBegin",
                typeof(long),
                typeof(TimelineClipControl),
                new FrameworkPropertyMetadata(
                    LongZeroObject,
                    FrameworkPropertyMetadataOptions.BindsTwoWayByDefault | FrameworkPropertyMetadataOptions.AffectsArrange,
                    (d, e) => {
                        if ((long) e.OldValue != (long) e.NewValue) {
                            TimelineClipControl control = ((TimelineClipControl) d);
                            Canvas.SetLeft(control, control.PixelStart);
                        }
                    },
                    (d, v) => (long) v < 0 ? LongZeroObject : v));

        public static readonly DependencyProperty FrameDurationProperty =
            DependencyProperty.Register(
                "FrameDuration",
                typeof(long),
                typeof(TimelineClipControl),
                new FrameworkPropertyMetadata(
                    LongZeroObject,
                    FrameworkPropertyMetadataOptions.BindsTwoWayByDefault | FrameworkPropertyMetadataOptions.AffectsMeasure,
                    null, (d, v) => (long) v < 0 ? LongZeroObject : v));

        public static readonly DependencyProperty IsDroppableTargetOverProperty =
            DependencyProperty.Register(
                "IsDroppableTargetOver",
                typeof(bool),
                typeof(TimelineClipControl),
                new PropertyMetadata(BoolBox.False));

        public static readonly DependencyProperty HeaderBrushProperty =
            DependencyProperty.Register(
                "HeaderBrush",
                typeof(Brush),
                typeof(TimelineClipControl),
                new PropertyMetadata(null));

        /// <summary>
        /// The zoom level of this timeline track
        /// <para>
        /// This is a value used for converting frames into pixels
        /// </para>
        /// </summary>
        public double UnitZoom => this.Track?.UnitZoom ?? 1d;

        [Category("Appearance")]
        public bool IsSelected {
            get => (bool) this.GetValue(IsSelectedProperty);
            set => this.SetValue(IsSelectedProperty, value);
        }

        /// <summary>
        /// The zero-based frame index where this element begins (relative to the parent timeline track)
        /// </summary>
        public long FrameBegin {
            get => (long) this.GetValue(FrameBeginProperty);
            set => this.SetValue(FrameBeginProperty, value);
        }

        /// <summary>
        /// This element's duration, in frames
        /// </summary>
        public long FrameDuration {
            get => (long) this.GetValue(FrameDurationProperty);
            set => this.SetValue(FrameDurationProperty, value);
        }

        public FrameSpan Span {
            get => new FrameSpan(this.FrameBegin, this.FrameDuration);
            set {
                this.FrameBegin = value.Begin;
                this.FrameDuration = value.Duration;
            }
        }

        /// <summary>
        /// The calculated width of this element based on the frame duration and zoom
        /// </summary>
        public double PixelWidth => this.FrameDuration * this.UnitZoom;

        /// <summary>
        /// The calculated render X position of this element based on the start frame, frame offset and zoom
        /// </summary>
        public double PixelStart => this.FrameBegin * this.UnitZoom;

        [Category("Appearance")]
        public Brush HeaderBrush {
            get => (Brush) this.GetValue(HeaderBrushProperty);
            set => this.SetValue(HeaderBrushProperty, value);
        }

        public bool IsDroppableTargetOver {
            get => (bool) this.GetValue(IsDroppableTargetOverProperty);
            set => this.SetValue(IsDroppableTargetOverProperty, value);
        }

        public event RoutedEventHandler Selected {
            add => this.AddHandler(SelectedEvent, value);
            remove => this.RemoveHandler(SelectedEvent, value);
        }

        public event RoutedEventHandler Unselected {
            add => this.AddHandler(UnselectedEvent, value);
            remove => this.RemoveHandler(UnselectedEvent, value);
        }

        public TimelineTrackControl Track => ItemsControl.ItemsControlFromItemContainer(this) as TimelineTrackControl;

        public TimelineControl Timeline => this.Track?.Timeline;

        public static readonly RoutedEvent SelectedEvent = Selector.SelectedEvent.AddOwner(typeof(TimelineClipControl));
        public static readonly RoutedEvent UnselectedEvent = Selector.UnselectedEvent.AddOwner(typeof(TimelineClipControl));

        private bool isProcessingAsyncDrop;
        private bool isUpdatingUnitZoom;
        private Point? lastLeftClickPoint;

        private Thumb PART_ThumbLeft;
        private Thumb PART_ThumbRight;
        private bool isLoadedWhileDraggingBody;

        public TimelineClipControl() {
            this.HorizontalAlignment = HorizontalAlignment.Left;
            this.VerticalAlignment = VerticalAlignment.Stretch;
            this.Focusable = true;
            this.AllowDrop = true;
            this.Drop += this.OnDrop;
            this.Loaded += this.OnLoaded;
        }

        private void OnLoaded(object sender, RoutedEventArgs e) {
            if (this.DataContext is ClipViewModel clip) {
                if (clip.dragInfo != null && clip.dragInfo.IsDraggingBody) {
                    this.isLoadedWhileDraggingBody = true;
                    this.IsSelected = true;
                    this.Focus();
                    this.CaptureMouse();
                }
            }

            this.Loaded -= this.OnLoaded;
        }

        public override void OnApplyTemplate() {
            base.OnApplyTemplate();
            this.HorizontalAlignment = HorizontalAlignment.Left;
            this.VerticalAlignment = VerticalAlignment.Stretch;
            this.PART_ThumbLeft = this.GetTemplateElement<Thumb>("PART_ThumbLeft");
            this.PART_ThumbRight = this.GetTemplateElement<Thumb>("PART_ThumbRight");
            this.PART_ThumbLeft.DragStarted += (s, e) => this.OnDragStart_ThumbLeft();
            this.PART_ThumbLeft.DragDelta += (s, e) => this.OnDragDelta_ThumbLeft();
            this.PART_ThumbLeft.DragCompleted += (s, e) => this.OnDragComplete_ThumbLeft(e.Canceled);
            this.PART_ThumbRight.DragStarted += (s, e) => this.OnDragStart_ThumbRight();
            this.PART_ThumbRight.DragDelta += (s, e) => this.OnDragDelta_ThumbRight();
            this.PART_ThumbRight.DragCompleted += (s, e) => this.OnDragComplete_ThumbRight(e.Canceled);
        }

        protected override Size MeasureOverride(Size constraint) {
            Size size = new Size(this.FrameDuration * this.UnitZoom, constraint.Height);
            if (this.VisualChildrenCount > 0) {
                UIElement visualChild = (UIElement) this.GetVisualChild(0);
                visualChild?.Measure(size); // shouldn't be null due to the VisualChildrenCount logic
            }

            return size;
        }

        private void OnDragStart_ThumbLeft() {
            if (!(this.DataContext is ClipViewModel handler))
                return;
            if (handler.dragInfo != null)
                throw new Exception("Already dragging");
            this.lastMousePoint_ThumbLeft = Mouse.GetPosition(Window.GetWindow(this));
            handler.dragInfo = ClipDragInfo.FromClip(handler);
            handler.dragInfo.IsDraggingLeft = true;
            foreach (ClipDragInfoData info in handler.dragInfo.clips) {
                info.clip.Track.AddSelected(info.clip);
            }
        }

        private Point lastMousePoint_ThumbLeft;
        private double accumulatedChange_ThumbLeft;

        private void OnDragDelta_ThumbLeft() {
            if (!(this.DataContext is ClipViewModel handler) || handler.dragInfo == null)
                return;
            // an accumulator is required, because some weird exponential thing happens when
            // this.lastMousePoint_ThumbLeft is set inside the if (change != 0) block and
            // the long change is calculated directly from PixelToFrame.
            // Not sure if it's floating point precision loss or because of how modifying FrameSpan changes the clip
            // size, therefore the location of the thumb that triggers this event, etc. etc.
            Point point = Mouse.GetPosition(Window.GetWindow(this));
            this.accumulatedChange_ThumbLeft += (point.X - this.lastMousePoint_ThumbLeft.X) / this.UnitZoom;
            this.lastMousePoint_ThumbLeft = point;

            long change = (long) this.accumulatedChange_ThumbLeft;
            if (change != 0) {
                this.accumulatedChange_ThumbLeft -= change;
                foreach (ClipDragInfoData info in handler.dragInfo.clips) {
                    FrameSpan last = info.DragLeft;

                    long begin = last.Begin + change + info.excess;
                    long endIndex = last.Begin + last.Duration;
                    if (begin < 0) {
                        info.excess += -(last.EndIndex - begin);
                        begin = 0;
                    }

                    FrameSpan span;
                    if (begin < endIndex) {
                        span = new FrameSpan(begin, last.Duration - (begin - last.Begin));
                    }
                    else {
                        info.excess = -(last.EndIndex - begin);
                        span = new FrameSpan(endIndex, 0);
                    }

                    info.clip.FrameSpan = info.DragLeft = span;
                    // long begin = last.Begin + change + info.excess;
                    // info.excess = 0;
                    // if (begin <= last.EndIndex) {
                    //     if (begin < 0) {
                    //         info.excess = -begin;
                    //         begin = 0;
                    //     }
                    //     info.clip.FrameSpan = info.DragLeft = last.AddBeginIndexClamped(begin);
                    // }
                    // else {
                    //     info.excess = -(last.EndIndex - begin);
                    //     info.clip.FrameSpan = info.DragLeft = new FrameSpan(last.EndIndex, 0);
                    // }
                }
            }
        }

        private void OnDragComplete_ThumbLeft(bool isCancelled) {
            if (!(this.DataContext is ClipViewModel handler) || handler.dragInfo == null)
                return;

            if (!handler.dragInfo.IsDraggingLeft)
                throw new Exception("Expected to be dragging Left thumb");

            foreach (ClipDragInfoData info in handler.dragInfo.clips) {
                if (isCancelled) {
                    info.clip.FrameSpan = info.OriginalSpan;
                }
                else {
                    if (info.clip.FrameSpan.IsEmpty)
                        info.clip.Track.RemoveClipFromTrack(info.clip);
                }
            }

            handler.dragInfo = null;
        }

        private void OnDragStart_ThumbRight() {
            if (!(this.DataContext is ClipViewModel handler))
                return;
            if (handler.dragInfo != null)
                throw new Exception("Already dragging");
            this.lastMousePoint_ThumbRight = Mouse.GetPosition(Window.GetWindow(this));
            handler.dragInfo = ClipDragInfo.FromClip(handler);
            handler.dragInfo.IsDraggingRight = true;
            foreach (ClipDragInfoData info in handler.dragInfo.clips) {
                info.clip.Track.AddSelected(info.clip);
            }
        }

        private Point lastMousePoint_ThumbRight;
        private double accumulatedChange_ThumbRight;

        private void OnDragDelta_ThumbRight() {
            if (!(this.DataContext is ClipViewModel handler) || handler.dragInfo == null)
                return;
            // an accumulator is required, because some weird exponential thing happens when
            // this.lastMousePoint_ThumbRight is set inside the if (change != 0) block and
            // the long change is calculated directly from PixelToFrame.
            // Not sure if it's floating point precision loss or because of how modifying FrameSpan changes the clip
            // size, therefore the location of the thumb that triggers this event, etc. etc.
            Point point = Mouse.GetPosition(Window.GetWindow(this));
            this.accumulatedChange_ThumbRight += (point.X - this.lastMousePoint_ThumbRight.X) / this.UnitZoom;
            this.lastMousePoint_ThumbRight = point;

            long change = (long) this.accumulatedChange_ThumbRight;
            if (change != 0) {
                this.accumulatedChange_ThumbRight -= change;
                long max = handler.Timeline.MaxDuration;
                foreach (ClipDragInfoData info in handler.dragInfo.clips) {
                    FrameSpan last = info.DragRight;
                    long endIndex = last.EndIndex + change + info.excess;
                    info.excess = 0;
                    if (endIndex <= last.Begin) {
                        info.excess = -(last.Begin - endIndex);
                        info.clip.FrameSpan = info.DragRight = new FrameSpan(last.Begin, 0);
                    }
                    else {
                        if (endIndex > max) {
                            max += Maths.Ceil(change, 250);
                            handler.Timeline.MaxDuration = max;
                            // info.excess = endIndex - max;
                            // endIndex = max;
                        }

                        long duration = endIndex - last.Begin;
                        info.clip.FrameSpan = info.DragRight = new FrameSpan(last.Begin, duration);
                    }
                }
            }
        }

        private void OnDragComplete_ThumbRight(bool isCancelled) {
            if (!(this.DataContext is ClipViewModel handler) || handler.dragInfo == null)
                return;

            if (!handler.dragInfo.IsDraggingRight)
                throw new Exception("Expected to be dragging right thumb");

            foreach (ClipDragInfoData info in handler.dragInfo.clips) {
                if (isCancelled) {
                    info.clip.FrameSpan = info.OriginalSpan;
                }
                else {
                    if (info.clip.FrameSpan.IsEmpty)
                        info.clip.Track.RemoveClipFromTrack(info.clip);
                }
            }

            handler.dragInfo = null;
        }

        protected override void OnPreviewMouseLeftButtonDown(MouseButtonEventArgs e) {
            base.OnPreviewMouseLeftButtonDown(e);
            this.Track?.MakeTopElement(this);
            // double width = this.ActualWidth;
            // double areaLeft = 8;
            // double areaRight = width - areaLeft + 1;
            // Point pos = e.GetPosition(this);
            // if (pos.X < areaLeft) {
            //     // this.OnDragStart_ThumbLeft();
            // }
            // else if (pos.X > areaRight) {
            //     this.OnDragStart_ThumbRight();
            // }

            // this.lastLeftClickPoint = e.GetPosition(this);
        }

        protected override void OnMouseLeftButtonDown(MouseButtonEventArgs e) {
            base.OnMouseLeftButtonDown(e);
            if (e.Handled) {
                return;
            }

            if (this.DataContext is ClipViewModel handler && (handler.dragInfo == null || !handler.dragInfo.IsDraggingBody)) {
                if (this.IsFocused || this.Focus()) {
                    if (!this.IsMouseCaptured) {
                        this.CaptureMouse();
                    }

                    this.lastLeftClickPoint = e.GetPosition(this);

                    if (KeyboardUtils.AreModifiersPressed(ModifierKeys.Control)) {
                        this.Track.SetItemSelectedProperty(this, true);
                    }
                    else if (KeyboardUtils.AreModifiersPressed(ModifierKeys.Shift) && this.Track.lastSelectedItem != null && this.Track.SelectedItems.Count > 0) {
                        this.Track.MakeRangedSelection(this.Track.lastSelectedItem, this);
                    }
                    else if (this.Track.Timeline.GetSelectedClipContainers().ToList().Count > 1) {
                        if (!this.IsSelected) {
                            this.Track.Timeline.SetPrimarySelection(this);
                        }
                    }
                    else {
                        this.Track.Timeline.SetPrimarySelection(this);
                    }

                    e.Handled = true;
                }
            }
        }

        protected override void OnMouseLeftButtonUp(MouseButtonEventArgs e) {
            this.lastLeftClickPoint = null;
            if (this.IsSelected && !KeyboardUtils.AreModifiersPressed(ModifierKeys.Control) && !KeyboardUtils.AreModifiersPressed(ModifierKeys.Shift) && this.Track.Timeline.GetSelectedClipContainers().ToList().Count > 1) {
                this.Track.Timeline.SetPrimarySelection(this);
            }

            base.OnMouseLeftButtonUp(e);
        }

        protected override void OnMouseMove(MouseEventArgs e) {
            base.OnMouseMove(e);
            if (!(this.DataContext is ClipViewModel clip)) {
                return;
            }

            if (e.MouseDevice.LeftButton != MouseButtonState.Pressed) {
                if (ReferenceEquals(e.MouseDevice.Captured, this))
                    this.ReleaseMouseCapture();
                this.lastLeftClickPoint = null;
            }
            else {
                Point mousePoint = e.GetPosition(this);
                if (!(this.lastLeftClickPoint is Point lastClickPoint)) {
                    return;
                }

                const double range = 8d;
                if (Math.Abs(lastClickPoint.X - mousePoint.X) < range && Math.Abs(lastClickPoint.Y - mousePoint.Y) < range) {
                    return;
                }

                // double diffX = mousePoint.X - lastClickPoint.X;
                // double diffY = mousePoint.Y - lastClickPoint.Y;
                // if (!didJustDragTrack && Math.Abs(diffY) >= 1.0d) {
                //     int index = 0;
                //     List<TimelineTrackControl> tracks = this.Timeline.GetTrackContainers().ToList();
                //     foreach (TimelineTrackControl track in tracks) {
                //         if (!(track.DataContext is TrackViewModel vm))
                //             continue;
                //         // IsMouseOver does not work
                //         Point mpos = e.GetPosition(track);
                //         if (mpos.Y >= 0 && mpos.Y < track.ActualHeight && vm.IsClipTypeAcceptable(clip))
                //             break;
                //         index++;
                //     }
                //     if (index < tracks.Count) {
                //         this.Timeline.ClipMousePosForTrackTransition = lastClickPoint;
                //         clip.OnDragToTrack(index);
                //     }
                // }
            }
        }

        protected override void OnKeyDown(KeyEventArgs e) {
            base.OnKeyDown(e);
            if (!e.Handled && e.Key == Key.Escape) {
                e.Handled = true;
            }
        }

        private void OnSelected(RoutedEventArgs e) {
            this.RaiseEvent(e);
        }

        private void OnUnselected(RoutedEventArgs e) {
            this.RaiseEvent(e);
        }

        private void OnFrameBeginChanged(long oldStart, long newStart) {
            TimelineUtils.ValidateNonNegative(newStart);
            if (oldStart != newStart) {
                this.UpdatePosition();
            }
        }

        private void OnFrameDurationChanged(long oldDuration, long newDuration) {
            TimelineUtils.ValidateNonNegative(newDuration);
            if (oldDuration != newDuration) {
                this.UpdateSize();
            }
        }

        #region Size Calculations

        public void OnUnitZoomChanged() {
            if (this.isUpdatingUnitZoom) {
                return;
            }

            try {
                this.isUpdatingUnitZoom = true;
                this.UpdatePosition();
                this.UpdateSize();
            }
            finally {
                this.isUpdatingUnitZoom = false;
            }
        }

        public void UpdatePosition() => Canvas.SetLeft(this, this.PixelStart);

        public void UpdateSize() => this.InvalidateMeasure();

        #endregion

        #region Drag Dropping

        protected override void OnDragOver(DragEventArgs e) {
            if (e.Data.GetDataPresent(ResourceListControl.ResourceDropType)) {
                object obj = e.Data.GetData(ResourceListControl.ResourceDropType);
                if (obj is BaseResourceObjectViewModel resource && this.DataContext is IAcceptResourceDrop drop && drop.CanDropResource(resource)) {
                    this.IsDroppableTargetOver = true;
                    e.Effects = DragDropEffects.Move;
                    e.Handled = true;
                    goto end;
                }
            }

            this.ClearValue(IsDroppableTargetOverProperty);
            e.Effects = DragDropEffects.None;

            end:
            e.Handled = true;
            base.OnDragOver(e);
        }

        protected override void OnDragLeave(DragEventArgs e) {
            base.OnDragLeave(e);
            this.Dispatcher.Invoke(() => {
                this.ClearValue(IsDroppableTargetOverProperty);
            }, DispatcherPriority.Loaded);
        }

        private void OnDrop(object sender, DragEventArgs e) {
            e.Handled = true;
            if (this.isProcessingAsyncDrop) {
                return;
            }

            this.isProcessingAsyncDrop = true;
            if (this.DataContext is IAcceptResourceDrop drop && e.Data.GetData(ResourceListControl.ResourceDropType) is BaseResourceObjectViewModel resource) {
                if (drop.CanDropResource(resource)) {
                    this.HandleOnDropResource(drop, resource);
                }
            }
        }

        private async void HandleOnDropResource(IAcceptResourceDrop acceptResourceDrop, BaseResourceObjectViewModel resource) {
            await acceptResourceDrop.OnDropResource(resource);
            this.ClearValue(IsDroppableTargetOverProperty);
            this.isProcessingAsyncDrop = false;
        }

        #endregion

        protected T GetTemplateElement<T>(string name) where T : DependencyObject {
            return this.GetTemplateChild(name) is T value ? value : throw new Exception($"Missing templated child '{name}' of type {typeof(T).Name} in control '{this.GetType().Name}'");
        }

        private void OnSelectionChanged(bool isSelected) {
            if (isSelected) {
                this.OnSelected(new RoutedEventArgs(SelectedEvent, this));
            }
            else {
                this.OnUnselected(new RoutedEventArgs(UnselectedEvent, this));
            }
        }
    }
}